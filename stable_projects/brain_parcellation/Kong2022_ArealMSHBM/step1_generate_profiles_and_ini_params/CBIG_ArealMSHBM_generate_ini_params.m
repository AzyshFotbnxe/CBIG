function CBIG_ArealMSHBM_generate_ini_params(seed_mesh, targ_mesh, lh_labels, rh_labels, out_dir)

% CBIG_ArealMSHBM_generate_ini_params(seed_mesh, targ_mesh, lh_labels, rh_labels, out_dir)
% This function will be used to generate initialization parameters. We will
% apply a given group-level parcellation on group averaged profiles generated
% by CBIG_MSHBM_avg_profiles.m.
%
% Input:
%
%   - seed_mesh:
%
%     The resolution of seed regions, e.g. 'fsaverage3' or 'fs_LR_900'. 
%     If the data is in fsaverage surface (e.g. fsaverage5/6), the 
%     seed_mesh should be defined by fsaverage surface in the same 
%     resolution as the data space, or lower resolution, e.g. fsaverage3/4. 
%     We also allow the data in fs_LR_32k, the only available seed_mesh is 
%     fs_LR_900, which is generated by CBIG lab.
%
%   - targ_mesh:
%
%     The surface space of fMRI data, e.g. 'fsaverage5' or 'fs_LR_32k'.
%     The data is allowed to be in either fsaverage space (e.g. 
%     fsaverage4/5/6, fsaverage) or fs_LR_32k. Note that fs_LR_164k is not
%     available.
%
%   - lh_labels rh_labels: (#vertices x 1 vector for both)
%     
%     Labels of a given group-level parcellation. The labels of both lh_labels
%     and rh_labels should starts from 1 to L. The medial wall area should be
%     denoted as 0.
%
%   - out_dir:
%
%     The clustering algoritm will be performed on the averaged profiles
%     saved in the following files:
%     For data in fsaverage space:
%     <out_dir>/profiles/avg_profile/lh_<targ_mesh>_roi<seed_mesh>_avg_profile.nii.gz
%     <out_dir>/profiles/avg_profile/rh_<targ_mesh>_roi<seed_mesh>_avg_profile.nii.gz
%     For data in fs_LR_32k space:
%     <out_dir>/profiles/avg_profile/<targ_mesh>_roi<seed_mesh>_avg_profile.nii.gz
%     
%     The initialization parameters will be saved in:
%     <out_dir>/group/group.mat
%
% Examples:
% CBIG_ArealMSHBM_generate_ini_params('fsaverage3', 'fsaverage5', lh_labels, rh_labels, './test_output')
%
% Written by Ru(by) Kong and CBIG under MIT license: https://github.com/ThomasYeoLab/CBIG/blob/master/LICENSE.md

    if(~exist(fullfile(out_dir,'group')))
        mkdir(fullfile(out_dir,'group'));
    end
    
    output_file = fullfile(out_dir,'group','group.mat');

    % read in mesh & parcellation
    if(~isempty(strfind(targ_mesh, 'fsaverage')))
        lh_targ_mesh = CBIG_ReadNCAvgMesh('lh', targ_mesh, 'inflated', 'cortex');
        rh_targ_mesh = CBIG_ReadNCAvgMesh('rh', targ_mesh, 'inflated', 'cortex');
        
        % medial wall is denoted as 1
        medial_mask = [lh_targ_mesh.MARS_label == 1 rh_targ_mesh.MARS_label == 1]';
    elseif(~isempty(strfind(targ_mesh, 'fs_LR')))
        lh_targ_mesh = CBIG_read_fslr_surface('lh', targ_mesh,'inflated','medialwall.annot');
        rh_targ_mesh = CBIG_read_fslr_surface('rh', targ_mesh,'inflated','medialwall.annot');
        
        % medial wall is denoted as 1
        medial_mask = [lh_targ_mesh.MARS_label == 1;rh_targ_mesh.MARS_label == 1];
    end
   
    lh_labels(lh_targ_mesh.MARS_label == 1) = 0;
    rh_labels(rh_targ_mesh.MARS_label == 1) = 0;
    
    if(strcmp(targ_mesh,'fs_LR_32k'))
        avg_profile_file = fullfile(out_dir,'profiles','avg_profile',[targ_mesh '_roi' seed_mesh '_avg_profile.mat']);
        load(avg_profile_file);

    elseif(~isempty(strfind(targ_mesh,'fsaverage'))) 
        lh_avg_profile_file = fullfile(out_dir,'profiles','avg_profile',...
            ['lh_' targ_mesh '_roi' seed_mesh '_avg_profile']);
        rh_avg_profile_file = fullfile(out_dir,'profiles','avg_profile',...
            ['rh_' targ_mesh '_roi' seed_mesh '_avg_profile']);
        if(exist([lh_avg_profile_file '.nii.gz']))
            lh_data = MRIread(lh_avg_profile_file);
            rh_data = MRIread(rh_avg_profile_file);
            lh_data.vol = reshape(lh_data.vol,size(lh_data.vol,1)*size(lh_data.vol,2)*size(lh_data.vol,3),...
                size(lh_data.vol,4));
            rh_data.vol = reshape(rh_data.vol,size(rh_data.vol,1)*size(rh_data.vol,2)*size(rh_data.vol,3),...
                size(rh_data.vol,4));

            profile_mat = [lh_data.vol; rh_data.vol];
        else
            lh_data = load([lh_avg_profile_file '.mat']);
            rh_data = load([rh_avg_profile_file '.mat']);
            profile_mat = [lh_data.profile_mat; rh_data.profile_mat];
        end
    end

    profile_mat(medial_mask, :) = 0;
    % Find if there is any all 0s row (including medial wall)
    non_zero = (sum(abs(profile_mat), 2) ~= 0);
    % Only keep the non-zero rows
    profile_mat(~non_zero, :) = [];
    profile_mat = bsxfun(@minus,profile_mat,mean(profile_mat, 2));
    profile_mat = bsxfun(@rdivide,profile_mat,sqrt(sum(profile_mat.^2,2)));

    % Feature dimension
    D = size(profile_mat,2)-1;

    % Given a parcellation, estimate vmf parameters mu (mean direction) and epsil (concentration parameter)
    %lambda
    rh_labels(rh_labels ~= 0) = rh_labels(rh_labels ~= 0) + max(lh_labels);
    labels = [lh_labels; rh_labels];
    missing_parcels = setdiff([0:1:max(labels)],unique(labels));
    if(~isempty(missing_parcels))
        labels_update = labels;
        for p = 1:length(missing_parcels)
            labels_update(labels > missing_parcels(p)) = labels_update(labels > missing_parcels(p)) - 1;
        end
        labels = labels_update;
    end
        
    
    lambda = zeros(length(labels),max(labels));
    rowindx = [1:1:length(labels)]';
    lambda(sub2ind(size(lambda),rowindx(labels ~= 0),labels(labels ~= 0))) = 1;
    lambda(labels == 0,:) = 0;
    lambda(~non_zero, :) = [];
    N = size(lambda,1);

    %mu
    mtc = profile_mat'*lambda;
    mtc = bsxfun(@times,mtc,1./sqrt(sum((mtc).^2)));

    %epsil
    epsil = invAd(D,sum(sum(lambda.*(profile_mat*mtc)))/N);

    % save results
    save(output_file,'mtc','epsil','lambda','lh_labels','rh_labels');


end

function [outu] = invAd(D,rbar)

    rbar = double(rbar);
    
    outu = (D-1).*rbar./(1-rbar.^2) + D/(D-1).*rbar;
    
    [i] = besseli(D/2-1,outu);
    
    
    if ((i == Inf)||(isnan(i)) || (i==0))
        out = outu - D/(D-1)*rbar/2;
        exitflag = Inf;
    else
        [outNew, fval exitflag]  = fzero(@(argum) Ad(argum,D)-rbar,outu);
        if exitflag == 1
            out = outNew;
        else
            out = outu - D/(D-1)*rbar/2;
        end
    end
end
